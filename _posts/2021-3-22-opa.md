---
layout: post
title: Open Policy Agent
---

In this blog we are going to talking about an interesting project called Open Policy Agent, which allows us to define policy as code in a seamlessly way, we are also going to work with rego files, which is the file that is used to evaluate a policy.

Open Policy Agent (OPA) is an open source project for declaring policy as code, using this tool we can allow or deny some action according our own rules (e.g: Deny kubernetes ingress controller creation if the image is not secure, Allow any http request for service A if Service B did the request, etc)


## Why do we need OPA?

In my case I use OPA for service-to-service authorization policy, this requirement could be easily done by the microservices itself but the drawback in doing this way is that we need to update this policy for every microservice, or even worse if our microservices are written in different languages the complexity is increased.

OPA solves this obstacle by providing us a tool that is language-agnostic and my opinion a simple way to define policies.


## Architecture

Internally OPA works with `rego` files which is used to define our policy rules and  `data.json` file wich is used as a datasource for compare any policy


![_config.yml]({{ site.baseurl }}/images/opa-architecture.png)


OPA basically is deployed wether a centrally policy server where all components send a request to check if a current request is allowed or not; or as sidecar  component where is deployed next to our components


### OPA as server policy

This kind of architecture is mostly used in scenarios where all of your components are in the same network or are very close to each other

![_config.yml]({{ site.baseurl }}/images/opa-server-install.png)


Drawbacks with this architecture is that you have a single point of failure, if for any reason your opa server goes down all components that send check policy will be affected

### OPA as sidecar policy

This is my favorite architecture because it solves the drawback of the opa server architecture, and the latency is shorter than the other one.

![_config.yml]({{ site.baseurl }}/images/opa-sidecar-install.png)

Drawbacks for this is that you need more resources because every opa will be present next to your component, thus if you have 10 microservices you will also have 10 opa sidecars


## 








