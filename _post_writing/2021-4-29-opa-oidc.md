---
layout: post
title: OPA + OIDC Integration
---

In this blog we are going to integrate OPA + Open Id Connect (OIDC) as part of our authorization policy.


## 1. Architecture

Internally OPA works with `rego` files which is used to define our policy rules and  `data.json` file wich is used as a datasource for compare any policy, the
policy and datasource is is against a input (http request, terraform command, etc)


TODO: Add Architecture Diagram

OPA basically is deployed wether a centrally policy server where all components send a request to check if a current request is allowed or not; or as sidecar  component where is deployed next to our components.


### 1.1. OIDC




## 2. Demo

Now it is time to get hands dirty, for this demo I will use Azure AD as my OIDC provider so the token that is in the input.json is a JWT generated by Azure. 

![_config.yml]({{ site.baseurl }}/images/opa-oidc-azure-postman.png)


### 2.1 Create Policy

Let's create our policy called `oidc.rego`

```go

package oidc

import input.attributes.request.http as http_request
import data.services["business-services-v1"] as resources

default allow = false

issuers = {"https://sts.windows.net/a6c36135-a633-4acd-94b2-06b54f179f92/"}

claims := io.jwt.decode(http_request.headers.authorization)[1]
metadata := metadata_discovery(claims.iss)

jwks := jwks_request(metadata.jwks_uri)

verified := io.jwt.verify_rs256(http_request.headers.authorization, json.marshal(jwks))


allow {
    is_token_valid
    action_allowed
}


is_token_valid {
    io.jwt.decode_verify(http_request.headers.authorization, {
                    "cert": json.marshal(jwks),
                    "iss": "https://sts.windows.net/a6c36135-a633-4acd-94b2-06b54f179f92/",
                    "alg": "RS256",
                    "aud": "api://caltamiranoapp",
    })[0]
}

action_allowed {

    some enp
    resources.services_security.endpoints[enp].uri == http_request.path
    resources.services_security.endpoints[enp].http_method == http_request.method

    enps := enp ; trace(sprintf("Endpoint : %v http method: %v", [resources.services_security.endpoints[enp].uri,
        resources.services_security.endpoints[enp].http_method]))

    some caller
    resources.services_security.endpoints[enp].allowed_callers_name[caller].name == http_request.headers.caller
    resources.services_security.endpoints[enp].allowed_callers_name[caller].channel == http_request.headers.channel

    cn := caller ; trace(sprintf("Caller index: %v",
        [resources.services_security.endpoints[enp].allowed_callers_name[cn].name]))

}

metadata_discovery(issuer) = http.send({
    "url": concat("", [issuers[issuer], ".well-known/openid-configuration"]),
    "method": "GET",
    "force_cache": true,
    "force_cache_duration_seconds": 60 # Cache response for 24 hours
}).body

jwks_request(url) = http.send({
    "url": url,
    "method": "GET",
    "force_cache": true,
    "force_cache_duration_seconds": 60 # Cache response for an hour
}).body

```

So basically we are telling OPA to allow a request if it comes with a valid JWT, and headers `channel` and `caller` match  with our datasource.

Be careful with the `decode_verify` method since if your JWT comes with the `aud` claim you must pass the `aud` constraint, `iss` constraint is opcional but I think is a good practice to set it otherwise any issuer is valid, JWT expiration es validated for default by the current time unless you specify the `time` constraint.

`force_cache` and `force_cache_duration_seconds` are very important atributes because for production environments that configuration allows to improve the latency at the time of policy validation.


### 2.2 Create datasource

Let's create a basic datasource called `data.json` which consist in list of endpoints that `service-a` application has, at the same time every endpoint has its own allowed callers so in this case  a caller `postman` from  channel `channel1` is able to call the endpoint `/api/v1/foo` for `post`and `get` http method respectively.    

```json
{
  "services": {
    "service-a": {
      "services_security": {
        "endpoints": [
           {
            "allowed_callers_name": [
              {
                "channel": "channel1",
                "http_method": [
                  "post",
                  "get"
                ],
                "name": "postman"
              }
            ],
            "http_method": "get",
            "uri": "/api/v1/foo"
          }
        ]
      }
    }
  }
}
```

### 2.3. Simulate a http input request

Now it is time to simulate our request, for it we create a file called `input.json` with the next content. 

```json
{
  "attributes": {
    "destination": {
      "address": {
        "Address": {
          "SocketAddress": {
            "PortSpecifier": {
              "PortValue": 8000
            },
            "address": "172.19.0.3"
          }
        }
      }
    },
    "request": {
      "http": {
        "headers": {
          ":authority": "localhost:8000",
          ":method": "GET",
          ":path": "/api/v1/foo",
          "accept": "*/*",
          "accept-encoding": "gzip, deflate, br",
          "authorization": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Im5PbzNaRHJPRFhFSzFqS1doWHNsSFJfS1hFZyIsImtpZCI6Im5PbzNaRHJPRFhFSzFqS1doWHNsSFJfS1hFZyJ9.eyJhdWQiOiJhcGk6Ly9jYWx0YW1pcmFub2FwcCIsImlzcyI6Imh0dHBzOi8vc3RzLndpbmRvd3MubmV0L2E2YzM2MTM1LWE2MzMtNGFjZC05NGIyLTA2YjU0ZjE3OWY5Mi8iLCJpYXQiOjE2MTk2NDM1MTAsIm5iZiI6MTYxOTY0MzUxMCwiZXhwIjoxNjE5NjQ3NDEwLCJhaW8iOiJFMlpnWUdpUW45aDBWbmwzcGMrODdHTXpIU3QxQUE9PSIsImFwcGlkIjoiNzYzNWY2MTEtNjUwZS00MGY4LWIyZjQtMmYxYjlkOTA4MzU2IiwiYXBwaWRhY3IiOiIxIiwiaWRwIjoiaHR0cHM6Ly9zdHMud2luZG93cy5uZXQvYTZjMzYxMzUtYTYzMy00YWNkLTk0YjItMDZiNTRmMTc5ZjkyLyIsIm9pZCI6IjcxMDZkM2IyLTM2NTItNGY4NC05MWMzLWVhNmY5MmExMjMxZSIsInJoIjoiMC5BU1VBTldIRHBqT216VXFVc2dhMVR4ZWZraEgyTlhZT1pmaEFzdlF2RzUyUWcxWWxBQUEuIiwic3ViIjoiNzEwNmQzYjItMzY1Mi00Zjg0LTkxYzMtZWE2ZjkyYTEyMzFlIiwidGlkIjoiYTZjMzYxMzUtYTYzMy00YWNkLTk0YjItMDZiNTRmMTc5ZjkyIiwidXRpIjoia3ZYSUJudVRqVXFHMnY4YXF0Tk5BUSIsInZlciI6IjEuMCJ9.Wo55J38coKrbjcRgrWzONFBPgkz-afdzQmACVd7Aldd-u3plW1JtaHmyOkU4nJ-JOnM91473oK6cBskvocEzWzfjc_M_r8kEtwxCvH4QlePnkbT_a0fmQ9DTj0q8v1LyqwcQkSRiB-NHWBvj7TrTWQ-C-oDUifRaFJMkDH_lvxUiGqDpHqlXWWnVwbfv5JCI9aEmc_ObTqnba3W4RWvYQ-E4lf8hGCV8RAXqz9H3vyc2H4xOP-tqEF5Co6GVzm0NZa7HcucMsdmXtkxKa5dNkyOT0NU5kCvpB3RyftwhvrFvXA1WibA9ku7ASpf-ie_wsItyPPamgroLSu9HC42ytw",
          "cache-control": "no-cache",
          "caller": "postman",
          "channel": "channel1"  
          "postman-token": "fc8a7b1c-4149-4fd5-bdf6-9c5183d6af09",
          "user-agent": "PostmanRuntime/7.26.8",
          "x-forwarded-proto": "http",
          "x-request-id": "1e47586e-7ec5-400e-b059-9ef299b2b0cc"
        },
        "host": "localhost:8000",
        "id": "15540377830434394261",
        "method": "GET",
        "path": "/api/v1/foo",
        "protocol": "HTTP/1.1"
      }
    }
  }
}
```


### 2.4. Test our policy

```bash
opa eval -f pretty --explain notes -d oidc.rego -d data.json	--input input.json 	data.oidc.allow
```

![_config.yml]({{ site.baseurl }}/images/opa-oidc-test-rego.png)


If everything is okey you should see the output true which means that the request is allowed, in case of JWT expired or incorrect aud claim you will get false 


## References

- [Open Policy Agent](https://www.openpolicyagent.org/)
- [Styra Blog OPA + OIDC](https://blog.styra.com/blog/integrating-identity-oauth2-and-openid-connect-in-open-policy-agent)







